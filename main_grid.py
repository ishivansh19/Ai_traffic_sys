import os
import sys
import traci
import numpy as np
from stable_baselines3 import DQN

# --- CONFIGURATION ---
os.environ['TF_ENABLE_ONEDNN_OPTS'] = '0'

# --- HELPER CLASSES ---
class SmartDetector:
    """
    A smarter version of our detector that dynamically finds lanes 
    for ANY traffic light, not just 'J1'.
    """
    def __init__(self, tls_id):
        self.tls_id = tls_id
        self.incoming_lanes = self._identify_incoming_lanes()
        
    def _identify_incoming_lanes(self):
        """
        Ask SUMO which lanes connect to this traffic light.
        Returns a dictionary mapping direction ('N','S','E','W') to lane IDs.
        """
        # Get all lanes controlled by this light
        controlled_lanes = traci.trafficlight.getControlledLanes(self.tls_id)
        # Use set to remove duplicates (SUMO lists lane multiple times if it has multiple connections)
        unique_lanes = list(set(controlled_lanes))
        
        # This is a simplified mapping. In a complex grid, we'd use geometric coordinates.
        # For a netgenerate grid, we just group them raw for queue counting.
        return unique_lanes

    def get_state(self):
        """
        Gets the occupancy for all incoming lanes.
        For the DQN, we need 4 inputs (N, S, E, W). 
        Since we can't easily know N/S/E/W on a random grid without complex geometry,
        we will split the lanes into 4 groups arbitrarily to fit the model input.
        """
        queues = []
        for lane in self.incoming_lanes:
            try:
                occ = traci.lane.getLastStepVehicleNumber(lane)
                queues.append(occ)
            except:
                queues.append(0)
        
        # Pad or Truncate to 4 inputs to match DQN input size
        # If we have 4 lanes, great. If 8 lanes (2 per side), we sum them up.
        total_lanes = len(queues)
        if total_lanes == 0:
            return [0, 0, 0, 0]
        
        # Divide into 4 roughly equal groups and sum them
        chunk_size = int(np.ceil(total_lanes / 4))
        model_inputs = [0, 0, 0, 0]
        
        for i in range(4):
            start = i * chunk_size
            end = min((i + 1) * chunk_size, total_lanes)
            if start < total_lanes:
                model_inputs[i] = sum(queues[start:end])
                
        return model_inputs

def run_grid_simulation():
    # 1. Load Model
    root_dir = os.path.dirname(os.path.abspath(__file__))
    model_path = os.path.join(root_dir, 'models', 'rl_agent', 'dqn_traffic')
    
    try:
        model = DQN.load(model_path)
        print("AI Brain Loaded. Applying to ALL grid intersections.")
    except:
        print("Error: Could not load model. Run training first.")
        return

    # 2. Launch SUMO with Grid Config
    sumo_binary = os.path.join(os.environ['SUMO_HOME'], 'bin', 'sumo-gui')
    config_path = os.path.join(root_dir, "simulation_grid", "grid.sumocfg")
    sumo_cmd = [sumo_binary, "-c", config_path]
    
    # Start simulation in the grid folder
    traci.start(sumo_cmd) # cwd logic not needed as config is self-contained generated by netgenerate
    
    # 3. Discovery Phase
    # Find all traffic lights in this new map
    tls_ids = traci.trafficlight.getIDList()
    print(f"Discovered {len(tls_ids)} Traffic Lights: {tls_ids}")
    
    # Create a detector for EACH light
    detectors = {tls: SmartDetector(tls) for tls in tls_ids}
    
    # Control variables per light
    last_actions = {tls: 0 for tls in tls_ids}
    
    step = 0
    min_green_time = 10
    yellow_time = 4
    
    try:
        while traci.simulation.getMinExpectedNumber() > 0:
            traci.simulationStep()
            
            if step % 100 == 0:
                 print(f"Step {step}...")

            # Loop through EVERY traffic light in the city
            for tls in tls_ids:
                # A. Get Data
                # This gets [Q1, Q2, Q3, Q4]
                queue_inputs = detectors[tls].get_state()
                
                # B. Get Phase
                current_phase = traci.trafficlight.getPhase(tls)
                
                # C. Prepare AI State [Q1, Q2, Q3, Q4, Phase]
                rl_state = np.array(queue_inputs + [current_phase], dtype=np.float32)
                
                # D. Ask the Shared Brain for a decision
                # We use the SAME model for ALL lights (Decentralized Control)
                action, _ = model.predict(rl_state, deterministic=True)
                
                # E. Apply Logic (Simplified for Grid)
                # Note: Generated grids often have simple Phase 0 (G), 1 (y), 2 (G), 3 (y) logic
                # Just like our training map.
                
                # Logic to prevent flickering (simplified)
                if step - last_actions[tls] > min_green_time:
                    if action == 0 and current_phase == 2: # Want Phase 0, currently 2
                        traci.trafficlight.setPhase(tls, 3) # Yellow
                        last_actions[tls] = step
                    elif action == 1 and current_phase == 0: # Want Phase 2, currently 0
                        traci.trafficlight.setPhase(tls, 1) # Yellow
                        last_actions[tls] = step
                    # Auto-switch from Yellow to Green
                    elif current_phase == 1 and step - last_actions[tls] > yellow_time:
                         traci.trafficlight.setPhase(tls, 2)
                    elif current_phase == 3 and step - last_actions[tls] > yellow_time:
                         traci.trafficlight.setPhase(tls, 0)

            step += 1
            
    except Exception as e:
        print(f"Simulation ended: {e}")
    finally:
        traci.close()

if __name__ == "__main__":
    run_grid_simulation()